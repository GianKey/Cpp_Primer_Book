# 第六章 函数
[toc]
## 1.函数基础

- **函数定义**：包括返回类型、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体。
- **调用运算符**：调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针。
- 圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断。
  - 2.被调函数（called function）开始执行。
- **形参和实参**：形参和实参的**个数**和**类型**必须匹配上。
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。
- **名字**：名字的作用于是程序文本的一部分，名字在其中可见。

### 1.1局部对象

- **生命周期**：对象的生命周期是程序执行过程中该对象存在的一段时间。
- **局部变量**（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是**隐藏**的。
- **自动对象**：只存在于块执行期间的对象。当块的执行结束后，它的值就变成**未定义**的了。
- **局部静态对象**： `static`类型的局部变量，生命周期贯穿函数调用前后。

### 1.2函数声明

- **函数声明**：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称**函数原型**。
- **在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义。
- **分离编译**： `CC a.cc b.cc`直接编译生成可执行文件；`CC -c a.cc b.cc`编译生成对象代码`a.o b.o`； `CC a.o b.o`编译生成可执行文件。
- main、函数定义、函数声明在三个不同的文件，通过一次编译告知地点，后要修改源文件，只要重新编译改过的文件

## 2.参数传递

- 形参初始化的机理和变量初始化一样。
- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

### 2.1传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量。
- 函数对形参做的所有操作都不会影响实参。
- **指针形参**：常用在C中，`C++`建议使用引用类型的形参代替指针。
  - 拷贝的是指针的值

### 2.2传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值。
- 引用形参直接关联到绑定的对象，而非对象的副本。
- 使用引用形参可以用于**函数返回额外的信息**。
- 经常用引用形参来避免不必要的复制。
- `void swap(int &v1, int &v2)`
- 如果无需改变引用形参的值，最好将其声明为常量引用。

### 2.3 const形参和实参

- 形参的顶层`const`编译后被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`。
- 我们可以使用非常量初始化一个底层`const`对象，但是反过来不行。
  - 非常量引用会限制传入实参的类型，如字面值，常量不行
  - 外常量形参，内非常量形参，调用同一个会错误
- 在函数中，如果把形参定义为非引用的const类型，不能改变实参的**局部副本**。
- 尽量使用常量引用。
- 规则可参考变量初始化

### 2.4 数组形参

- 数组特殊性质影响传递
  - 不允许拷贝数组 - 不能值传递
  - 使用数组时通常会把它转为指针
- 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
- ```c++
  void print(const int*);
  void print(const int[]);
  int i = 0,j[2] = {0,1};
  print(&i);
  print(j);
  ```
- 要注意数组的实际长度，不能越界。
  - 传递数组长度方法
    - 使用标记指定数组长度，如char *最后会有空格
    - 标准库规范：传递数组首元素指针和尾后元素指针，`begin(arr),end(arr);`
    - 显式传递数组大小的形参
  - 传递多维数组
  - ```cpp 
      void print(int (*matriz)[10], int rowsize)
      //matrix指向数组的首元素，该数组的元素是由10个整数构成的数组
    ```
  

### 2.5 main处理命令行选项

- `int main(int argc, char *argv[]){...}`
  - argv[0]保存文件名，用户输入从1开始
- 第一个形参代表参数的个数；第二个形参是参数C风格字符串数组。
- 我们可以向程序传入以下选项`prog -d -o ofile data0`
- ```cpp
  argv[0] = "prog"; argv[1] = "-d"; argv[2] = "-o";
  argv[3] = "ofile"; argv[4] = "data0"; argv[6] = "0";
  ```

### 2.6 可变形参
传递可变数量参数
如果所有实参类型相同，可以传递initializer_list的标准库类型

`initializer_list`提供的操作（`C++11`）：

| 操作 | 解释 |
|-----|-----|
| `initializer_list<T> lst;` | 默认初始化；`T`类型元素的空列表 |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)` | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst` | 同上 |
| `lst.size()` | 列表中的元素数量 |
| `lst.begin()` | 返回指向`lst`中首元素的指针 |
| `lst.end()` | 返回指向`lst`中微元素下一位置的指针 |

`initializer_list`使用demo：

```cpp
void err_msg(ErrCode e, initializer_list<string> il){
    cout << e.msg << endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
    cout << endl;
}

err_msg(ErrCode(0), {"functionX", "okay});
```

- 所有实参类型相同，可以使用 `initializer_list`的标准库类型。
  - 内的元素是常量不可改变
- 实参类型不同，可以使用`可变参数模板`。
- 省略形参符： `...`，便于`C++`访问某些C代码，这些C代码使用了 `varargs`的C标准功能。
  - 只能出现在形参列表最后一位

## 3.返回类型和return语句

### 3.1 无返回值函数

没有返回值的 `return`语句只能用在返回类型是 `void`的函数中，返回 `void`的函数不要求非得有 `return`语句。

### 3.2 有返回值函数

- `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型。
- 值的返回：返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果。
- **不要返回局部对象的引用或指针**。
  - 函数内局部变量、字面值都会转为局部临时对象
- **引用返回左值**：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。
  - ```c++
       char &get_val(string &str, string::size_type ix)
       {
         return str[ix];
       }
       int main()
       {
         string s("a value");
         get_val(s, 0) = 'A'; //将s[0]的值改为A
       }
    ```
- **列表初始化返回值**：函数可以返回花括号包围的值的列表。（`C++11`）
- **主函数main的返回值**：如果结尾没有`return`，编译器将隐式地插入一条返回0的`return`语句。返回0代表执行成功。
  - cstdlib我文件中定义两个变量返回，保证与机器无关

### 3.3 返回数组指针

- 因为数组不能被拷贝，但是可以返回数组指针和引用，语法上定义一个返回数组引用或指针的函数比较繁琐，可以用类型别名
- 一、`Type (*function (parameter_list))[dimension]`
- 二、使用类型别名： `typedef int arrT[10];` 或者 `using arrT = int[10;]`，然后 `arrT* func() {...}`
- 三、使用 `decltype`： `decltype(odd) *arrPtr(int i) {...}`
  - 函数返回的数组已知
  - 返回结果是数组，不负责吧数组类型转成指针，所以加上*
- 四、**尾置返回类型**： 在形参列表后面以一个`->`开始：`auto func(int i) -> int(*)[10]`（`C++11`）
  - 任何函数都可以，但是对返回类型比较复杂的函数比较有效

## 4.函数重载

- **重载**：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。
- `main`函数不能重载。
- 不允许重载只有返回类型不同，其他一样的函数
- **重载和const形参**：
  - 一个有顶层const的形参和没有它的函数无法区分。 `Record lookup(Phone* const)`和 `Record lookup(Phone*)`无法区分。
  - 相反，是否有某个底层const形参可以区分。 `Record lookup(Account*)`和 `Record lookup(const Account*)`可以区分 
  - 使用const_cast 实现重写实参传入非常量引用，返回普通引用，而不是强制返回底层引用
- 调用重载函数
  - 函数匹配-重载确定
  - 最佳匹配
  - 无匹配
  - 二义性调用
- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。
  - C++中查找名字发生在类型检查之前

## 5.特殊用途语言特性

### 5.1 默认实参

- `string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');`
- 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。
- 小心省略和默认实参顺序时的类型转换
- 重复声明含有默认实参的函数
  - 后一次声明是能弥补之前没有设定默认值的实参，且该形参右侧所有形参都必须有默认值
- 局部变量不能作为默认实参
  - 局部变量不能隐藏外层定义的同名默认实参

### 5.2 内联（inline）函数
将表达式形式的一些操作定义为函数，有一系列好处，但是调用速度会比调用表达式慢
- 内联函数可以避免函数调用的开销
  - 一般选择内联那些规模小，流程直接（非递归），频繁调用的函数
- 内联函数，通常就是将它在每个调用点上“内联地展开”
- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数。
- `inline`函数应该在头文件中定义。
- 类内定义的函数默认是内联，也可以在外部声明

### 5.3 constexpr函数

- 指能用于常量表达式的函数。
- `constexpr int new_sz() {return 42;}`
- 函数的返回类型及所有形参类型都要是字面值类型。
- 函数体中必须有且只有return
- `constexpr`函数应该在头文件中定义。
- 为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数
- constexpr内可以有其他语句，只要这些语句运行时不执行任何操作
- constexpr函数不一定返回常量表达式
  - 若返回的是实参的指针，若`arg是常量表达式，scale(arg)也是常量表达式`
```c++
constexpr size_t scale(size_t cnt) {return new_sz() *cnt}
```

### 5.4 调试帮助
c++程序员有时会用到类似头文件保护的技术，以便有选择地执行调试代码。思想是：程序可以包含一些用于调试的代码，但是这些代码只能在开发调试时使用。当完成发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能`assert和NDEBUG`


- `assert`预处理宏（preprocessor macro）：`assert(expr);`
- 若expr为假，assert输出信息并终止程序执行，若为真assert什么也不做
- 在cassert中，与其他预处理变量一样宏名字在程序内必须唯一。含有cassert头文件的程序，不能再定义名为assert的变量，函数或其他实体
- 预处理变量由预处理器而非编译器管理

开关调试状态：
- assert的行为依赖NDEBUG预处理变量，若定义了NDEBUG则assert什么也不做。默认状态没有定义
- 使用`#define NDEBUG`
- `CC -D NDEBUG main.c`可以定义这个变量`NDEBUG`。

- 编译器定义`_ _ func_ _`,表示当前调试函数的名字
  - `_ _FILR_ _`存放文件名字符串字面值
  - `_ _LINE_ _`存放当前行号整型字面值
  - `_ _TIME_ _`存放文件编译时间字符串
  - `_ _DATE_ _`存放文件编译日期字符串ß

```cpp
void print(){
    #ifndef NDEBUG
        cerr << __func__ << "..." << endl;
    #endif
}
```

## 6.函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。
- **候选函数**：选定本次调用对应的重载函数集（函数同名，其声明在调用点可见），集合中的函数称为候选函数（candidate function）。
- **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
  - 形参数量与本次实参数量相等
  - 每个实参类型与对于形参相同，或是能转换成形参类型
  - 若没有可行，编译器报无匹配错误
- **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。
  - 该函数每个实参匹配都不劣于其他可行函数
  - 至少有一个实参匹配优于其他可行参数
  - 若没有报二义性调用

## 7. 函数指针

- **函数指针**：是指向函数的指针。
- `bool (*pf)(const string &, const string &);` 注：两端的括号不可少。
- 使用函数指针
  - 给函数指针赋值时&可选，因为会自动把函数名转换成指针
  - 调用是*解引用可选
- **重载函数指针**
  - 编译器通过指针类型决定哪个函数，指针类型必须于重载函数中的某一个精确匹配
```c++
void ff(int*);
void ff(unsigned int);

void(*pf1)(unsigned int) = ff; //pf1指向ff(unsigned)

void (*pf2)(int)=ff; //错误
double (*pf3)(int*) = ff; //错误
```
- **函数指针形参**：
  - 形参中使用函数定义或者函数指针定义效果一样。
    - 会自动转换成指针
  - 使用类型别名或者`decltype`。 
    - decltype返回的是函数类型，不会自动转化成指针,显式加上*表明返回指针，而非函数本身
```c++
string::size_type sumLength(const string&, const string&);
string::size_type largerLength(const string&, const string&);

//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength的指针
decltype(sumLength) *getFcn(const string &);
```
- **返回指向函数的指针**：1.类型别名；2.尾置返回类型。
    - 和函数类型的形参不一样，返回类型不会自动地转换为指针，必须显式地将返回类型指定为指针
```c++
using F = int(int*, int); //F是函数类型，不是指针
using PF = int(*)(int*, int); //PF是指针类型

PF f1(int); //正确：PF是指向函数的指针，f1返回指向函数的指针
F f1(int);  //错误：F是函数类型，f1不能返回一个函数
F *f1(int); //正确：显式地指定返回类型是指向函数的指针
int (*f1(int)) (int*,int); //正确，f1(int) int指定返回类型
auto f1(int) -> int (*)(int*, int);
```
