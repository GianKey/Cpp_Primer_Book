# 第七章 类 （Class）

## 定义抽象数据类型

- **类背后的基本思想**：**数据抽象**（data abstraction）和**封装**（encapsulation）。
- 数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）分离的编程技术。

### 类成员 （Member）

- 必须在类的内部声明，不能在其他地方增加成员。
- 成员可以是数据，函数，类型别名。

### 类的成员函数

- 成员函数的**声明**必须在类的内部。
- 成员函数的**定义**既可以在类的内部也可以在外部。
- 使用点运算符 `.` 调用成员函数。
- 必须对任何`const`或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。
- `ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }`
- 默认实参： `Sales_item(const std::string &book): isbn(book), units_sold(0), revenue(0.0) { }`
- `*this`：
  - 每个成员函数都有一个额外的，隐含的形参`this`。
  - `this`总是指向当前对象，因此`this`是一个常量指针。
  - 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）this 类型: const Sales_data * const。
  - `return *this;`可以让成员函数连续调用。
  - 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）Sales_data *const。
  - `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址）。
    - `double Sales_data::avg_price() const{};`
  - 一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用
  - 如果成员函数被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性

### 非成员函数

- 和类相关的非成员函数，定义和声明都应该在类的外部。
- 一般来说是类的接口组成部分，函数声明应该和类在一个头文件内

### 类的构造函数

- 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。
  - 不同的构造函数参数数量和类型要有区别
  - 不能把构造函数声明成const，类的对象在构造完后才有const属性，期间可以往对象中写值
- 构造函数是特殊的成员函数。
- 构造函数放在类的`public`部分。
- 与类同名的成员函数。

#### 默认构造函数
- 若没有声明，显示调用，由编译器创建-合成的默认构造函数
- 只适用于非常简单的类
- `Sales_datas（）=default` c++11，`=default`要求编译器合成默认的构造函数。(`C++11`)
  - 我们既需要其他形式的构造函数，也需要默认的构造函数
  - 如果编译器不支持类内初始值，那么你的默认构造函数就应该用构造函数初始值列表，来初始化类的每个成员
#### 构造函数初始值列表
- `Sales_item(): units_sold(0), revenue(0.0) { }`
- 初始化列表：冒号和花括号之间的代码： `Sales_item(): units_sold(0), revenue(0.0) { }`  
  - `Sales_data(const std::string &s) : boolNo(s) {}`
  - 一般参数赋予类内初始值，若编译器不支持类内初始值，所有构造函数应该显式初始化每个内置类型成员
- 没有在初始化列表中的参数，会通过类内初始值初始化（如果存在），或者执行默认初始化

#### 在类外定义构造函数
- `Sales_data::Sales_data(std::istream &is) { read(is, *this); }`read的作用是从is读取一条信息然后存入this对象中
  
## 拷贝、赋值和析构
类控制拷贝、赋值和销毁对象时发生的行为
- 一般未定义，编译器会替我们合成
- 但是有些类合成会失效，如当类需要分配类对象之外的资源时

## 访问控制与封装

- **访问说明符**（access specifiers）：
  - `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
  - `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。
- 使用 `class`或者 `struct`：都可以被用于定义一个类。唯一的却别在于访问权限。
  - 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
  - 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

### 友元

- 允许特定的**非成员函数**访问一个类的**私有成员**.
- 友元的声明以关键字 `friend`开始。 `friend Sales_data add(const Sales_data&, const Sales_data&);`表示非成员函数`add`可以访问类的非公有成员。
- 通常将友元声明成组地放在**类定义的开始或者结尾**。
  - 为了使友元函数对用户可见
    - 友元声明一般仅仅是访问权限声明，而非通常意义上的函数声明
    - 在友元声明之外专门对函数进行一次声明
    - 放在同一个头文件中
- 类之间的友元：
  - 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

### 封装的益处

- 确保用户的代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

## 类的其他特性
- 类型别名，定义一个类型成员
  - `typedef/using` 类型别名可以是private或public定义访问权限
  - 先定义后使用
```c++
class Screen{
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
}
```
- 成员函数作为内联函数 `inline`：
  - 在类的内部，常有一些规模较小的函数适合于被声明成内联函数。
  - **定义**在类内部的函数是**自动内联**的。
  - 在类外部定义的成员函数，也可以在声明时显式地加上 `inline`。
- **可变数据成员** （mutable data member）：
  - `mutable size_t access_ctr;`
  - 永远不会是`const`，即使它是`const`对象的成员。
  - 任何成员函数都可以改变这个数据成员变量
- **类数据成员的初始值**
  - 当我们初始化类 类型的成员时，需要为构造函数传递一个符合成员类型的实参。
  - `vector存储类的对象`初始化，{使用那个类的构造函数}列表初始化或者=
```c++
class Window_mgr {
private:
      std::vector<Screen> screens{ Screen(24,80, '')};
}
```
- **基于const的重载**
  - 因为非常量版本函数对于常量对象不可用，只能在一个常量对象上调用const成员函数
  - 根据对象是否是常量，决定使用哪个重载函数
    - `Screen &dispaly()/const Screen &display()`
- **类类型**：
  - 每个类定义了唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。
  - 支持声明和定义分离，先声明后定义类 `class opq`。先声明类，这种声明有时被称作前向声明
    - 在前向声明定义之前，它是一个不完全类型
      - 不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明作为参数或返回类型的函数。但是创建对象前，类必须被定义过。
- **友元再探**
  - 还可以令其他类和其他类的函数作为友元
    - `friend class Window_mgr;`若一个类被声明成类友元，则它可以访问此类的所有成员
    - 也可以单独令其他类的函数为友元`friend void Window_magr::clear(ScreenIndex);` 必须明确声明函数属于的类
      - 若要想把多个同名重载函数都声明成友元，必须一个个声明。
      - 被声明成友元的函数必须在类的外部提供相应声明。友元的作用时影响访问权限，而非普通意义上的声明。

## 类的作用域

- 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。
- 函数的**返回类型**通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。
- 如果成员使用了外层作用域中的某个名字，而该名字代表一种**类型**，则类不能在之后重新定义该名字。
- 类中的**类型名定义**都要放在一开始。
- **名字查找和类的作用域**
  - 普通程序名字查找
    - 先在其所在块中寻找声明语句，只考虑在名字的使用之前出现的声明
    - 若没有找到，继续在外层作用域查找
    - 若最终没有找到匹配的声明，则程序报错
  - 定义在类内部的成员函数
    - 首先，编译成员声明
    - 直到类全部可见后才编译函数体
  - 类的成员函数名字查找
    - 首先在成员函数内查找该名字声明。只有在函数使用该名字之前的声明才被考虑
    - 若成员函数内未找到，则在类内查找，这时类的所有成员都可以被考虑
    - 若类内也未找到该名字的声明，在成员函数定义之前的作用域内继续查找
    - `cursor = width * ::height; ` 显示说明height是全局的

## 构造函数再探

- 构造函数初始值列表：
  - 类似`python`使用赋值的方式有时候不行，比如`const`或者引用类型的数据，只能初始化，不能赋值。（注意初始化和赋值的区别）
    - 初始化是直接的，赋值是先初始化再赋值
  - 如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。
  - 构造函数的初始值有时候必不可少
    - 如果成员时const或者引用的话，必须将其初始化
    - 当成员属于某种类型且该类没有定义默认构造函数时，也必须将这个成员初始化
  - 最好让构造函数初始值的顺序和成员声明的顺序保持一致。
    - 避免使用其他成员初始化该成员
    - 成员初始化顺序和构造函数参数列表属性无关，以成员声明顺序为主
      - 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序
  - 如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数。

### 委托构造函数 （delegating constructor, `C++11`）

- 委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，委托构造函数将自己的职责委托给了其他构造函数。
- 参数列表中必须与类中另外一个构造函数匹配
```c++
Sales_data(stdLLstring s, unsigned cnt, double price): 
            bookNo(s), units_sold(cnt), revenue(cnt*price){}
Sale_data(std::istream &is): Sale_data("", 0, 0) {read(is,*this);}
```
- 委托给了默认构造函数，默认构造函数又接着委托给三参数构造函数。当这些受委托的构造函数执行完后，接着执行istream&构造函数体的内容。

### 默认构造函数的作用
- 当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生：
  - 在块作用域内不使用任何初始值定义一个非静态变量或者数组时
  - 当类本身含有类类型的成员且使用合成的默认构造函数
  - 当类类型的成员没有在构造函数初始值列表中显式地初始化时
- 值初始化发生情况：
  - 在数组初始化过程中如果提供的初始值数量少于数组的大小时
  - 不使用初始值定义一个局部静态变量时
  - 当通过书写形如T（）的表达式显式地请求值初始化时，其中T为类型名
- 类必须包含一个默认构造函数以便在上述情况下使用，实际中如果定义了其他构造函数，最好也提供一个默认构造函数
- 使用默认构造函数,想定义一个使用默认构造函数进行初始化的对象
  - 'Sales_data obj'去掉对象名后的空括号
### 隐式的类型转换

- 如果构造函数**只接受一个实参**，则它实际上定义了转换为此类类型的**隐式转换机制**。这种构造函数又叫**转换构造函数**（converting constructor）。
  - 如一个函数接受的形参为某个类，但是我们提供的实参为其类的某个成员，那么会创建该类的一个临时对象，其余成员将默认初始化
- 编译器只会自动地执行`仅一步`类型转换。
- 抑制构造函数定义的隐式转换：
  - 将构造函数声明为`explicit`加以阻止。
  - `explicit`构造函数只能用于直接初始化，不能用于拷贝形式的初始化。
  - 只对一个实参的构造函数有效，因为需要多个实参的构造函数不能用于执行隐式转换
  - 只能才类内声明时加上，在类外部定义时不应重复
  - 不能将explicit标注过的构造函数用于=赋值拷贝式的初始化
  - explicit标注构造函数后，仍可以显示转换 `item.combin(Sales_data(null_book));`

### 聚合类 （aggregate class）

- 满足以下所有条件：
  - 所有成员都是`public`的。
  - 没有定义任何构造函数。
  - 没有类内初始值。
  - 没有基类，也没有`virtual`函数。
- 可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致,数量不可多。

### 字面值常量类

- `constexpr`函数的参数和返回值必须是字面值。
- 构造函数不能是const，但字面值常量类的构造函数可以是constexpr，且字面值常量类必须至少提供一个constexpr构造函数
- **字面值类型**：除了算术类型、引用和指针外，某些类也是字面值类型。
- 数据成员都是字面值类型的聚合类是字面值常量类。
- 如果不是聚合类，则必须满足下面所有条件：
  - 数据成员都必须是字面值类型。
  - 类必须至少含有一个`constexpr`构造函数。
  - 如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`构造函数。
  - 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

## 类的静态成员
有的时候类需要一些成员与类本身直接相关，而不是和各个对象保持关联
- 非`static`数据成员存在于类类型的每个对象中。
- `static`数据成员独立于该类的任意对象而存在。
- 每个`static`数据成员是与类关联的对象，并不与该类的对象相关联。
- 声明：
  - 声明之前加上关键词`static`。
  - 不能声明成const
- 使用：
  - 使用**作用域运算符**`::`直接访问静态成员:`r = Account::rate();`
  - 也可以使用对象访问：`r = ac.rate();`
  - 静态成员不包含this指针，不能在static函数内使用this指针
  - 成员函数不需要提供作用域访问符就能直接访问
- 定义：
  - 在类外部定义时不用加`static`。
  - 类内声明加上
- 初始化：
  - 通常不在类的内部初始化，而是在定义时进行初始化，如 `double Account::interestRate = initRate();`
  - 如果一定要在类内部定义
    - 可以为静态成员提供const整数类型的类内初始值
      - 则要求静态成员必须是字面值常量类型的`constexpr`。
      - 初始值必须是常量表达式
    - 类内初始化
    - 内部只能定义一次
  - 即使一个常量静态数据成员在类内被初始化了，最好在类外也定义一下该成员（不带初始值
-  特性
   -  类型可以是不完全类型（类型就为本类
   -  可以使用静态成员作为默认实参，非静态成员不行 