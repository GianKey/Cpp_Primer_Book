# 第二章 变量和基本类型
[toc]

### 基本内置类型

**基本算数类型**：

| 类型 | 含义 | 最小尺寸|
|---|---|---|
| `bool` | 布尔类型  | 8bits |
| `char`| 字符 | 8bits |
| `wchar_t` | 宽字符 | 16bits |
| `char16_t` | Unicode字符 | 16bits |
| `char32_t` | Unicode字符 | 32bits |
| `short` | 短整型 | 16bits |
| `int` | 整型 | 16bits (在32位机器中是32bits) |
| `long` | 长整型 | 32bits |
| `long long` | 长整型 | 64bits （是在C++11中新定义的） |
| `float` | 单精度浮点数 | 6位有效数字 |
| `double` | 双精度浮点数 | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |


### 如何选择类型

- 1.当明确知晓数值不可能是负数时，选用无符号类型；
- 2.使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`。
- 3.算术表达式中不要使用`char`或`bool`，只有存放字符或布尔值时才使用它们。
- 4.浮点运算选用`double`。

### 类型转换

- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。
- 浮点数->整数型，取整
- 赋给无符号类型一个超出它表示范围的值，结果是初始值对无符号类型表示数值总数取模后的余数。
- 给有符号类型超出范围的值，结果是未定义的。
#### 含有无符号类型的表达式
  - 无符号数+/-有符号数，有符号数->无符号数
  - 机器里数字--补码
    - 补码加法与减法统一用加法表示

### 字面值常量

- 一个形如`42`的值被称作**字面值常量**（literal）。
  - 整型和浮点型字面值。
  - 字符和字符串字面值。
    - 使用空格连接，继承自C。
    - 字符字面值：单引号， `'a'`
    - 字符串字面值：双引号， `"Hello World""`
    - 末尾会添加一个空字符('\0')，s所以字符串长度+1
    - 多行分写字符串，(onnly 空格，缩进，换行，字符组成)实际一个整体
  - 转义序列。`\n`、`\t`等。
    - \x+16进制，`0XA8`,`0xA*`
    - \+1/2/3个8进制,`024`
  - 布尔字面值。`true`，`false`。
  - 指针字面值。`nullptr`

## 变量

**变量**提供一个**具名**的、可供程序操作的存储空间。   `C++`中**变量**和**对象**一般可以互换使用。

### 变量定义（define）

- **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`
- **初始化**（initialize）：对象在创建时获得了一个特定的值。
  - **初始化不是赋值！**：
  - 初始化 = 创建变量 + 赋予初始值
  - 赋值 = 擦除对象的当前值 + 用新值代替
- 初始化的多种方式
  - **列表初始化**：使用花括号`{}`，如`int units_sold{0};int units_sold(0);int units_sold={0}`
    - 使用括号初始化，若`{a}`a存在丢失风险则会编译报错
  - 默认初始化：定义时没有指定初始值会被默认初始化；在函数体内部的内置类型变量将不会被初始化。
    - 一个违背初始化的内置类型变量是未定义的
  - 建议初始化每一个内置类型的变量。

### 变量的**声明**（declaration） vs **定义**（define）
  - 为了支持分离式编译，`C++`将声明和定义区分开。**声明**使得名字为程序所知。**定义**负责创建与名字关联的实体。
    - 声明和定义都规定变量类型和名字，但是定义还申请存储空间（付初始值）
  - **extern**：只是说明变量定义在其他地方。
  - 只声明而不定义： 在变量名前添加关键字 `extern`，如`extern int i;`。但如果包含了初始值，就变成了定义：`extern double pi = 3.14;`
  - 变量只能被定义一次，但是可以多次声明。
- 名字的**作用域**（namescope）
  - {},始于声明，结束于声明的作用域
  - 全局作用域
  - 块级作用域
  - 第一次使用变量再定义它
- 嵌套作用域
  - 内部能看到外部
>静态类型语言：C++，含义：在编译极端检查类型--类型检查，如检查数据是否支持相应对象的操作。
 -标识符：不能连续两个__，不能_后接大写字母开头，定义在函数体之外的标识符不能以_开头


## 左值和右值

- **左值**（l-value）**可以**出现在赋值语句的左边或者右边，比如变量；
- **右值**（r-value）**只能**出现在赋值语句的右边，比如常量。


## 复合类型
基于其他类型定义的类型。
声明语句：基本数据类型+声明符列表（命名一个变量+指定该变量为与基本数据类有关的某种类型）

### 引用

- **引用**：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如`int &refVal = val;`。一般指左值引用
- 引用本身不是对象
- 引用必须初始化。且初始值必须是一个对象，初始化严格对于相应数据类型
- 引用和它的初始值是**绑定bind**在一起的，而**不是拷贝**。

### 指针

- 是一种 `"指向（point to）"`另外一种类型的复合类型。
- 与引用
  - 同：都可以间接访问其他对象
  - 不同
    - 指针本身是一个对象，允许对指针赋值和拷贝，在生命周期内可以先后指向不同对象,引用一旦绑定就不能改对象
    - 无需在定义时赋初值
    - 在块作用域内定义未初始化，会拥有一个不确定值
- **定义**指针类型： `int *ip1;`，**从右向左读**，`ip1`是指向`int`类型的指针。
- 指针存放某个对象的**地址**。要想获得地址要使用取地址符`int *p = &ival`
- 获取对象的地址： `int i=42; int *p = &i;`。 `&`是**取地址符**。
- 指针的值的四种状态：
  - 1.指向一个对象；
  - 2.指向紧邻对象的下一个位置；
  - 3.空指针；
  - 4.无效指针。
    - **编译器不检查错误：试图拷贝或者以其他方式访问无效指针的值的错误**
    - 也不能试图访问2，3类型指针
- 指针访问对象： `cout << *p;`， `*`是**解引用符**。仅适用于1型指针
- 空指针不指向任何对象。`int *p = nullptr/0/NULL`
- `void*`指针可以存放**任意**对象的地址。
- 其他指针类型必须要与所指对象**严格匹配**。
----
- 指向指针的指针 `**,***...`
- 指向指针的引用`int *p = 0;int *&r = p`
  - r是一个对指针p的引用
- 变量读从右往左：离变量越近的符号对变量有最直接影响
- ----
- 两个指针相减的类型是`ptrdiff_t`。
- 建议：初始化所有指针。

## const限定符

- 动机：希望定义一些不能被改变值的变量。

### 初始化和const
- const对象**必须初始化**，且**不能被改变**。
- `const in bs = 512`编译器会把所有用到bs的地方替换成512
- const变量默认不能被其他文件访问，非要访问，必须在指定const前加extern。


### const的引用

- **reference to const**（对常量的引用）：指向const对象的引用，如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。
  - `int &r2 = ival`错误非常量引用不能指向常量
  - 常量引用是对const的引用
#### 初始化和对常量引用
- 两种情况引用类型不用和所引用对象类型一致
  - 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型
- **临时量**（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。
- 对临时量的引用是非法行为。

#### 对const的引用可以是引用一个非const对象
- `int i = 42;int &r1 = i;const int &r2 = i`
- `r1 = 0对;r2 = 0 错`

### 指针和const

- **pointer to const**（指向常量的指针）：不能用于改变其所指对象的值, 如 `const double pi = 3.14; const double *cptr = &pi;`。
- **const pointer**：指针本身是常量，如 `int i = 0; int *const ptr = &i;`
  - `int *const curErr = &err`curErr将一直指向err
  - `const double *const pip = &pi`pip是一个指向常量对象的常量指针

### 顶层const

- `顶层const`：指针本身是个常量。
- `底层const`：指针指向的对象是个常量。拷贝时严格要求相同的底层const资格。
  - 拷贝考出时，考入考出对象必须有相同的底层const资格
  - 或者两个对象的数据类型可以转换---非常量可以变成常量
  - 顶层const在拷贝时不受影响

### `constexpr`和常量表达式

- 常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。
- `C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。
  - 声明为constexpr的变量一定是常量，且必须用常量表达式初始化

## 处理类型

### 类型别名

- 传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;typedef wages base, *p;`
- 新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）

### auto类型说明符

- **auto**类型说明符：让编译器**自动推断类型**。
- `int i = 0, &r = i; auto a = r;` 推断`a`的类型是`int`。
- 会忽略`顶层const`。
- `const int ci = 1; const auto f = ci;`推断类型是`int`，需要自己加`const`
- auto &g ==&g初始化规则，=右边的顶层常量会被忽略
- `C++11`

### decltype类型指示符

- 从表达式的类型推断出要定义的变量的类型。但不想用表达式的值初始化
- **decltype**：选择并返回操作数的**数据类型**。
- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。
- 不会忽略`顶层const`。
- `int i=0,*p=&i;decltype(*p) c`c 是int&类型，必须初始化
- `dec;type((i))`加了括号的变量，结果是引用
- `C++11`

## 自定义数据结构

### struct

- 类可以以关键字`struct`开始，紧跟类名和类体。
- 类数据成员：类体定义类的成员。
- `C++11`：可以为类数据成员提供一个**类内初始值**（in-class initializer）。
- struct Foo{初始化}

### 编写自己的头文件

- 头文件通常包含哪些只能被定义一次的实体：类、`const`和`constexpr`变量。

预处理器概述：

- **预处理器**（preprocessor）：确保头文件多次包含仍能安全工作。
  - 在编译之前执行的一段程序
- 当预处理器看到`#include`标记时，会用指定的头文件内容代替`#include`
- **头文件保护符**（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。
- 预处理变量无视c++作用域规则

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
strct Sale_data{
    ...
}
#endif
```
