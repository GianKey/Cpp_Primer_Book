# 第九章 顺序容器
[toc]
## 顺序容器概述

- **顺序容器**（sequential container）：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

### 顺序容器类型

| 容器类型 | 介绍 |
|-----|-----|
| `vector` | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 |
| `deque` | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。 |
| `list` | 双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快。 |
| `forward_list` | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 |
| `array` | 固定大小数组。支持快速随机访问。不能添加或者删除元素。 |
| `string` | 与`vector`相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。 |

- 除了固定大小的`array`外，其他容器都提供高效、灵活的内存管理。
- `forward_list`和`array`是新C++标准增加的类型。
- 通常使用`vector`是最好的选择，除非你有很好的理由选择其他容器。
- 新标准库的容器比旧版的快得多。
- 容器选取基本原则
  - 一般选Vector
  - 如果程序有许多很小的元素，且空间的额外开销很重要，则不要使用list或forward_list
  - 如果程序要求随机访问元素，应使用vector或deque
  - 如果程序要求在容器中间插入或删除元素，应该使用list或者forward_list
  - 如果程序需要在头尾位置插入或删除元素，但不会再中间位置进行插入删除，则使用deque
  - 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素
    - 首先确定是否真的需要在中间位置插入删除元素，当处理输入数据时，可以很容易地向vector追加数据，然后再调用标准库sort函数来重排元素，从而避免在中间位置添加元素
    - 如必须在中间位置插入元素，考虑在输入阶段使用list一旦输入完成，将list中的内容拷贝到一个vector中
  - 如果不确定使用哪个容器，可以在程序中只使用vector和list的公共操作；使用迭代器，避免下标操作，避免随机访问。

## 容器操作

### 类型

| 操作 | 解释 |
|-----|-----|
| `iterator` | 此容器类型的迭代器类型 |
| `const_iterator` | 可以读取元素但不能修改元素的迭代器类型 |
| `size_type` | 无符号整数类型，足够保存此种容器类型最大可能的大小 |
| `difference_type` | 带符号整数类型，足够保存两个迭代器之间的距离 |
| `value_type` | 元素类型 |
| `reference` | 元素的左值类型；和`value_type &`含义相同 |
| `const_reference` | 元素的`const`左值类型，即`const value_type &` |

### 构造函数

| 操作 | 解释 |
|-----|-----|
| `C c;` | 默认构造函数，构造空容器 |
| `C c1(c2);`或`C c1 = c2;` | 构造`c2`的拷贝`c1` |
| `C c(b, e)` | 构造`c`，将迭代器`b`和`e`指定范围内的所有元素拷贝到`c` |
| `C c(a, b, c...)` | 列表初始化`c` |
| `C c(n)` | 只支持顺序容器，且不包括`array`，包含`n`个元素，这些元素进行了值初始化。只有顺序容器的构造函数才接受大小参数，关联容器不可以，但要求元素类型要有默认构造函数 |
| `C c(n, t)` | 包含`n`个初始值为`t`的元素 |
|`C c{a,b,c...},C c={a,b,c...}`| ` `|

| | |
|-----|-----|
|只有顺序容器（不包括array）的构造函数才能接受大小参数|
|`C seq(n)` | seq包含n哥元素，这些元素进行值初始化：此构造函数是explicit是的（string不适用 |
|`C seq(n,t)` | seq包含n个初始化为值t的元素 |


- 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。
- `array`具有固定大小。
- 和其他容器不同，默认构造的`array`是非空的。
- 直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。
- 使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。

### 赋值和`swap`

| 操作 | 解释 |
|-----|-----|
| `c1 = c2;` | 将`c1`中的元素替换成`c2`中的元素 |
| `c1 = {a, b, c...}` | 将`c1`中的元素替换成列表中的元素（不适用于`array`） |
| `c1.swap(c2)` | 交换`c1`和`c2`的元素 |
| `swap(c1, c2)` | 等价于`c1.swap(c2)` |
| `c.assign(b, e)` | 将`c`中的元素替换成迭代器`b`和`e`表示范围中的元素，`b`和`e`不能指向`c`中的元素 |
| `c.assign(il)` | 将`c`中的元素替换成初始化列表`il`中的元素 |
| `c.assign(n, r)` | 将`c`中的元素替换为`n`个值是`t`的元素 |

- 使用非成员版本的`swap`是一个好习惯。
  - 赋值相关操作会导致指向左边容器内部的迭代器，引用和指针失效
  - swap交换两个相同类型容器的内容
  - 元素本身并未交换，swqp只交换两个容器的内部数据结构
  - 对string，swap会导致迭代器，引用和指针失效
  - swap会真正交换array中的元素，交换所需时间和array中的元素成正比
- `assign`操作不适用于关联容器和`array`
  - assign允许相容类型容器间的赋值

### 大小

| 操作 | 解释 |
|-----|-----|
| `c.size()` | `c`中元素的数目（不支持`forward_list`） |
| `c.max_size()` | `c`中可保存的最大元素数目 |
| `c.empty()` | 若`c`中存储了元素，返回`false`，否则返回`true` |

### 关系运算符
- 除了无序关联容器外的所有容器都支持关系运算符
- 关系运算符左右两边必须是相同类型（容器类型+元素类型）
  - 实际上是逐个比较
- 容器的关系运算符使用元素的关系运算符完成比较

## 顺序容器操作
### 添加元素

| 操作 | 解释 |
|-----|-----|
| `c.push_back(t)` | 在`c`尾部创建一个值为`t`的元素，返回`void` |
| `c.emplace_back(args)` | 同上 |
| `c.push_front(t)` | 在`c`头部创建一个值为`t`的元素，返回`void` ，list，forward_list，deque|
| `c.emplace_front(args)` | 同上 |
| `c.insert(p, t)` | 在迭代器`p`指向的元素之前创建一个值是`t`的元素，返回指向新元素的迭代器 |
| `c.emplace(p, args)` | 同上 ，构造而不是拷贝元素|
| `c.insert(p, n, t)` | 在迭代器`p`指向的元素之前插入`n`个值为`t`的元素，返回指向第一个新元素的迭代器；如果`n`是0，则返回`p` |
| `c.insert(p, b, e)` | 将迭代器`b`和`e`范围内的元素，插入到`p`指向的元素之前；如果范围为空，则返回`p` |
| `c.insert(p, il)` | `il`是一个花括号包围中的元素值列表，将其插入到`p`指向的元素之前；如果`il`是空，则返回`p` |

- 因为这些操作会改变大小，因此不适用于`array`。
- `forward_list`有自己专有版本的`insert`和`emplace`。
- `forward_list`不支持`push_back`和`emplace_back`。
- 当我们用一个对象去初始化容器或者将对象插入到容器时，实际上放入的是对象的拷贝。
- `emplace`开头的函数是新标准引入的，这些操作是构造而不是拷贝元素。
- 传递给`emplace`的参数必须和元素类型的构造函数相匹配。
- 向一个vector、string、deque插入元素会使所有指向容器的迭代器、引用和指针失效
- 容器元素是拷贝（容器初始化时）
- emplace将参数传递给元素类型的构造函数
  - emplace直接在容器管理的内存中创建对象
  - push创建临时局部对象，并压入容器
  - 传递给emplace函数的参数必须与元素类型的构造函数相匹配

### 访问元素

| 操作 | 解释 |
|-----|-----|
| `c.back()` | 返回`c`中尾元素的引用。若`c`为空，函数行为未定义，每个顺序容器都有，除了forward_list |
| `c.front()` | 返回`c`中头元素的引用。若`c`为空，函数行为未定义 |
| `c[n]` | 返回`c`中下标是`n`的元素的引用，`n`时候一个无符号证书。若`n>=c.size()`，则函数行为未定义 |
| `c.at(n)` | 返回下标为`n`的元素引用。如果下标越界，则抛出`out_of_range`异常 |

- 访问成员函数返回的是引用。（front,back,下标和at)
- `at`和下标操作只适用于`string`、`vector`、`deque`、`array`。
  - `sevc.at(0)`如果0越界抛出out_of_range错误
- `back`不适用于`forward_list`。
- 如果希望下标是合法的，可以使用`at`函数。

### 删除元素

| 操作 | 解释 |
|-----|-----|
| `c.pop_back()` | 删除`c`中尾元素，若`c`为空，则函数行为未定义。函数返回`void` |
| `c.pop_front()` | 删除`c`中首元素，若`c`为空，则函数行为未定义。函数返回`void` |
| `c.erase(p)` | 删除迭代器`p`指向的元素，返回一个指向被删除元素之后的元素的迭代器，若`p`本身是尾后迭代器，则函数行为未定义 |
| `c.erase(b, e)` | 删除迭代器`b`和`e`范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若`e`本身就是尾后迭代器，则返回尾后迭代器 |
| `c.clear()` | 删除`c`中所有元素，返回`void` |

- 会改变容器大小，不适用于`array`。
- `forward_list`有特殊版本的`erase`
- `forward_list`不支持`pop_back`
- `vector`和`string`不支持`pop_front，push_front`

### 特殊的forwad_list操作

- 链表在删除元素时需要修改前置节点的内容，双向链表会前驱的指针，但是单向链表没有保存，因此需要增加获取前置节点的方法。
- `forward_list`定义了`before_begin`，即首前（off-the-begining）迭代器，允许我们再在首元素之前添加或删除元素。

| 操作 | 解释 |
|-----|-----|
| `lst.before_begin()` | 返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。 |
| `lst.cbefore_begin()` | 同上，但是返回的是常量迭代器。 |
| `lst.insert_after(p, t)` | 在迭代器`p`之后插入元素。`t`是一个对象 |
| `lst.insert_after(p, n, t)` | 在迭代器`p`之后插入元素。`t`是一个对象，`n`是数量。若`n`是0则函数行为未定义 |
| `lst.insert_after(p, b, e)` | 在迭代器`p`之后插入元素。由迭代器`b`和`e`指定范围。 |
| `lst.insert_after(p, il)` | 在迭代器`p`之后插入元素。由`il`指定初始化列表。返回指向最后一个插入元素的迭代器，若空，返回p，上同 |
| `emplace_after(p, args)` | 使用`args`在`p`之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若`p`为尾后迭代器，则函数行为未定义。 |
| `lst.erase_after(p)` | 删除`p`指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若`p`指向`lst`的尾元素或者是一个尾后迭代器，则函数行为未定义。 |
| `lst.erase_after(b, e)` | 类似上面，删除对象换成从`b`到`e`指定的范围。 |

### 改变容器大小

| 操作 | 解释 |
|-----|-----|
| `c.resize(n)` | 调整`c`的大小为`n`个元素，若`n<c.size()`，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
| `c.resize(n, t)` | 调整`c`的大小为`n`个元素，任何新添加的元素都初始化为值`t` |

- resize不适用于array

-----
### 容器操作可能使迭代器失效

- 在向容器添加元素后
  - vector和string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效
  - deque，插入到除首尾位置之外的任何位置都导致...失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效
  - list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效
- 删除
  - list 和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效
  - deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果删除尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果删除首元素，这些也不会受影响
  - vector和string，指向被删除元素之前的元素的迭代器、引用和指针仍有效
  - 注意：当我们删除元素时，尾后迭代器总是会失效
    - 不要保存end返回的迭代器，要反复调用`v.end()`

### 获取迭代器

| 操作 | 解释 |
|-----|-----|
| `c.begin()`, `c.end()` | 返回指向`c`的首元素和尾元素之后位置的迭代器 |
| `c.cbegin()`, `c.cend()` | 返回`const_iterator` |

- 以`c`开头的版本是C++11新标准引入的
- 当不需要写访问时，应该使用`cbegin`和`cend`。

### 反向容器的额外成员

| 操作 | 解释 |
|-----|-----|
| `reverse_iterator` | 按逆序寻址元素的迭代器 |
| `const_reverse_iterator` | 不能修改元素的逆序迭代器 |
| `c.rbegin()`, `c.rend()` | 返回指向`c`的尾元素和首元素之前位置的迭代器 |
| `c.crbegin()`, `c.crend()` | 返回`const_reverse_iterator` |

- 不支持`forward_list`

### 迭代器

- 迭代器范围：`begin`到`end`，即第一个元素到最后一个元素的后面一个位置。
- 左闭合区间：`[begin, end)`
- 左闭合范围蕴含的编程设定：
  - 如果`begin`和`end`相等，则范围为空。
  - 如果二者不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素。
  - 可以对`begin`递增若干次，使得`begin == end`。

### 容器操作可能使迭代器失效

- 在向容器添加元素后：
  - 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。
  - 对于`deque`，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。
  - 对于`list`和`forward_list`，指向容器的迭代器、指针和引用依然有效。
- 在从一个容器中删除元素后：
  - 对于`list`和`forward_list`，指向容器其他位置的迭代器、引用和指针仍然有效。
  - 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除`deque`的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是`deque`的头元素，这些也不会受影响。
  - 对于`vector`和`string`，指向被删元素之前的迭代器、引用、指针仍然有效。
  - 注意：当我们删除元素时，尾后迭代器总是会失效。
  - 注意：使用失效的迭代器、指针、引用是严重的运行时错误！
  - 建议：将要求迭代器必须保持有效的程序片段最小化。
  - 建议：不要保存`end`返回的迭代器。

> 每次向容器增加删除元素后，都正确地重新定位迭代器

### 容器内元素的类型约束

- 元素类型必须支持赋值运算；
- 元素类型的对象必须可以复制。
- 除了输入输出标准库类型外，其他所有标准库类型都是有效的容器元素类型。
  
### 将一个容器初始化为另一个容器的拷贝
- 直接指定被拷贝的容器
  - 要求容器类型和元素类型必须相同
  - `list<string> author; list<string> list2(author)`
- 通过迭代器指定范围拷贝
  - 不要求容器类型相同，元素类型也可以不同，只要可以元素转换
  - `vector<const char*> articles; forward_list<string> word(articles.begin(),articles.end())`
  - 左闭右开

### 标准库array具有相同固定大小
- 要指定容器大小
  - `array<int, 42；array<int, 10> ia1;`
  - `array,int, 10>::size_type i;`
  - 不能对内置数组类型进行拷贝或对象进行复制操作，但是array并无次限制


## vector对象是如何增长的

`vector`和`string`在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。

`capacity`操作告诉我们容器在不扩张内存空间的情况下可以容纳多少元素

### 管理容量的成员函数

| 操作 | 解释 |
|-----|-----|
| `c.shrink_to_fit()` | 将`capacity()`减少到和`size()`相同大小 |
| `c.capacity()` | 不重新分配内存空间的话，`c`可以保存多少个元素 |
| `c.reverse(n)` | 分配至少能容纳`n`个元素的内存空间，影响预先分配的内存空间 |

- `shrink_to_fit`只适用于`vector`、`string`和`deque`
- `capacity`和`reverse`只适用于`vector`和`string`。
- resize只改变容器中元素的数目，而不是容器的容量

----

## 额外的string操作

### 构造string的其他方法

| 操作 | 解释 |
|-----|-----|
| `string s(cp, n)` | `s`是`cp`指向的数组中前`n`个字符的拷贝，此数组 |
| `string s(s2, pos2)` | `s`是`string s2`从下标`pos2`开始的字符的拷贝。若`pos2 > s2.size()`，则构造函数的行为未定义。 |
| `string s(s2, pos2, len2)` | `s`是`string s2`从下标`pos2`开始的`len2`个字符的拷贝。 |

- `n`,`len2`,`pos2`都是无符号值。
- 这些函数接受string或const char*
  - 从const char*创建时，该数组必须以空字符结尾拷贝操作遇到空字符时停止
    - 传递计数值的构造函数，不用空字符，但是计数值不能大于const char*的大小

### substr操作

| 操作 | 解释 |
|-----|-----|
| `s.substr(pos, n)` | 返回一个`string`，包含`s`中从`pos`开始的`n`个字符的拷贝。`pos`的默认值是0，`n`的默认值是`s.size() - pos`，即拷贝从`pos`开始的所有字符。pos，n可选 |

### 改变string的其他方法
- 支持顺序容器的赋值运算符，assign，insert和erase操作。还定义了额外的instert和erase版本。
除了接受迭代器的insert哥erase版本外，string还提供接受下标版本
  - `s.insert(s.size(),5,'!');`在s末尾插入5个！
  - `s.erase(s.size()-5,5)`删除最后5个字符
  - `s.insert(0,s2,0,s2.size())`
  - `s.insert(0,s2)`
- string还提供接受C风格字符数组的insert和assign版本
  - `s.assign(cp,7)`
  - `s.insert(s.size(),cp+7);`
- `s2.replace(11,3,"5th")`从位置11开始，删除3个字符并插入5th

| 操作 | 解释 |
|-----|-----|
| `s.insert(pos, args)` | 在`pos`之前插入`args`指定的字符。`pos`可以使是下标或者迭代器。接受下标的版本返回指向`s`的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。 |
| `s.erase(pos, len)` | 删除从`pos`开始的`len`个字符，如果`len`被省略，则删除后面所有字符，返回指向`s`的引用。 |
| `s.assign(args)` | 将`s`中的字符替换成`args`指定的字符。返回一个指向`s`的引用。 |
| `s.append(args)` | 将`args`指定的字符追加到`s`，返回一个指向`s`的引用。 |
| `s.replace(range, args)` | 删除`s`中范围`range`中的字符，替换成`args`指定的字符。返回一个指向`s`的引用。 |

------
-----

| arg可以是以下形式 | append和assign可以使用所有形式｜
|-----|-----|
| str不能与s相同 |  迭代器b和e不能指向s|
| str    |字符串str|
|str,pos,len |str 中从pos开始最多len个字|
|cp,len | 从cp指向的字符数组的前（最多）len个字符|
|cp | cp指向的以空字符结尾的字符数组|
|n,c|n个字符c|
|b,e|迭代器b和e指定范围内的字符|
|初始化列表| {,} |
-------

replace和insert的arg形式
-----
| (pos,len,args) | (b,e,args) | (pos,args)| (iter,args)| args |
|-----| ----| ---| ------| -------|
| replace| replace| insert |insert| args
|-----|-----|----| --------| -----|
|  |  |  | x|str |
|  | x |  |x |str,pos,len |
|  |  |  | x|cp,len |
|  |  | x | x|cp |
|  |  |  | |n,c |
| x |  | x | |b2,e2 |
| x |  | x | |初始化列表 |
x不可以

### string搜索操作

- `string`类提供了6个不同的搜索函数，每个函数都有4个重载版本。
- 每个搜索操作都返回一个`string::size_type`值，表示匹配发生位置的下标。如果搜索失败则返回一个名为`string::npos`的`static`成员（类型是`string::size_type`，初始化值是-1，也就是`string`最大的可能大小）。
- 都是unsigned类型

| 搜索操作 | 解释 |
|-----|-----|
| `s.find(args)` | 查找`s`中`args`第一次出现的位置 |
| `s.rfind(args)` | 查找`s`中`args`最后一次出现的位置 |
| `s.find_first_of(args)` | 在`s`中查找`args`中任何一个字符第一次出现的位置 |
| `s.find_last_of(args)` | 在`s`中查找`args`中任何一个字符最后一次出现的位置 |
| `s.find_first_not_of(args)` | 在`s`中查找第一个不在`args`中的字符 |
| `s.find_first_not_of(args)` | 在`s`中查找最后一个不在`args`中的字符 |

args必须是一下的形式之一：

| `args`形式 | 解释 |
|-----|-----|
| `c, pos` | 从`s`中位置`pos`开始查找字符`c`。`pos`默认是0 |
| `s2, pos` | 从`s`中位置`pos`开始查找字符串`s2`。`pos`默认是0 |
| `cp, pos` | 从`s`中位置`pos`开始查找指针`cp`指向的以空字符结尾的C风格字符串。`pos`默认是0 |
| `cp, pos, n` | 从`s`中位置`pos`开始查找指针`cp`指向的前`n`个字符。`pos`和`n`无默认值。 |

-----
### s.compare的几种参数形式

逻辑类似于C标准库的`strcmp`函数，根据`s`是等于、大于还是小于参数指定的字符串，`s.compare`返回0、正数或负数。

| 参数形式 | 解释 |
|-----|-----|
| `s2` | 比较`s`和`s2` |
| `pos1, n1, s2` | 比较`s`从`pos1`开始的`n1`个字符和`s2` |
| `pos1, n1, s2, pos2, n2` | 比较`s`从`pos1`开始的`n1`个字符和`s2` |
| `cp` | 比较`s`和`cp`指向的以空字符结尾的字符数组 |
| `pos1, n1, cp` | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的以空字符结尾的字符数组 |
| `pos1, n1, cp, n2` | 比较`s`从`pos1`开始的`n1`个字符和`cp`指向的地址开始`n2`个字符 |

### string和数值转换
实现数值数据与标准库string之间的转换

| 转换 | 解释 |
|-----|-----|
| `to_string(val)` | 一组重载函数，返回数值`val`的`string`表示。`val`可以使任何算术类型。对每个浮点类型和`int`或更大的整型，都有相应版本的`to_string()`。和往常一样，小整型会被提升。 |
| `stoi(s, p, b)` | 返回`s`起始子串（表示整数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0，`b`是转换所用的基数。返回`int` |
| `stol(s, p, b)` | 返回`long` |
| `stoul(s, p, b)` | 返回`unsigned long` |
| `stoll(s, p, b)` | 返回`long long` |
| `stoull(s, p, b)` | 返回`unsigned long long` |
| `stof(s, p)` | 返回`s`起始子串（表示浮点数内容）的数值，`p`是`s`中第一个非数值字符的下标，默认是0。返回`float` |
| `stod(s, p)` | 返回`double` |
| `stold(s, p)` | 返回`long double` |

## 容器适配器（adapter）
stack，queue和priority_queue，容器、迭代器和函数都有适配器

- 适配器是使一事物的行为类似于另一事物的行为的一种机制，例如`stack`可以使任何一种顺序容器以栈的方式工作。
- 初始化 `deque<int> deq; stack<int> stk(deq);` 从`deq`拷贝元素到`stk`。
- 创建适配器时，指定一个顺序容器，可以覆盖默认的基础容器： `stack<string, vector<string> > str_stk;`。

### 容器适配器的通用操作和类型

| 操作 | 解释 |
|-----|-----|
| `size_type` | 一种类型，须以保存当前类型的最大对象的大小 |
| `value_type` | 元素类型 |
| `container_type` | 实现适配器的底层容器类型 |
| `A a;` | 创建一个名为`a`的空适配器 |
| `A a(c)` | 创建一个名为`a`的适配器，带有容器`c`的一个拷贝 |
| 关系运算符 | 每个适配器都支持所有关系运算符：`==`、`!=`、`<`、 `<=`、`>`、`>=`这些运算符返回底层容器的比较结果|
| `a.empty()` | 若`a`包含任何元素，返回`false`;否则返回`true` |
| `a.size()` | 返回`a`中的元素数目 |
| `swap(a, b)` | 交换`a`和`b`的内容，`a`和`b`必须有相同类型，包括底层容器类型也必须相同 |
| `a.swap(b)` | 同上 |

### 定义一个适配器
每个适配器有两个构造函数
- 默认构造函数，创建一个空对象
- 接受u一个容器参数的构造函数，拷贝该容器来 初始化适配器
  - `deque<int> dep;stack<int> stk(dep);`
-  一般stack和queue是基于deque实现，priority_queue是在vector上实现
  - 限制
    - 基于实现的容器，可以添加删除元素,访问尾元素，array不行，也不能用forward_list
    - 具体是适配器特性有不同限制，例如要求头尾增删
- 只可以使用适配器操作，不能使用底层基于实现容器的操作


### stack

| 操作 | 解释 |
|-----|-----|
| `s.pop()` | 删除栈顶元素，不返回。 |
| `s.push(item)` | 创建一个新元素，压入栈顶，该元素通过拷贝或移动`item`而来 |
| `s.emplace(args)` | 同上，但元素由`args`来构造。 |
| `s.top()` |  返回栈顶元素，不删除。|

- 定义在`stack`头文件中。
- `stack`默认基于`deque`实现，也可以在`list`或`vector`之上实现。
- `stack<string, vector<string>> str_stk(svec);`第二个参数重载默认容器类型，在vector上实现的栈
  
### queue和priority_queue
都定义在queue头文件中

| 操作 | 解释 |
|-----|-----|
| `q.pop()` | 删除队首元素，但不返回。 |
| `q.front()` | 返回队首元素的值，不删除。 |
| `q.back()` | 返回队尾元素的值，不删除。只适用于`queue` |
| `q.top()` | 返回具有最高优先级的元素值，不删除。只适用于priority_queue |
| `q.push(item)` | 在队尾压入一个新元素。 |
| `q.emplace(args)` | 其值为item或由args构造 |

- 定义在`queue`头文件中。
- `queue`默认基于`deque`实现，`priority_queue`默认基于`vector`实现。
- `queue`可以在`list`或`vector`之上实现，`priority_queue`也可以用`deque`实现。
- priority_queue 允许我们为队列中的元素建立优先级。
  - 新加入的元素会排在所有优先级比它低的已有元素之前，
  - 饭店预定和来店时间
  - 标准库在元素类型上使用`<`运算符来确定相对优先级
