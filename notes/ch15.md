# 第十五章 面向对象程序设计

[toc]

## OOP：概述

- 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。
  - 数据抽象--将类的接口与实现分离
  - 继承--可定义相似的类型并对其相似关系建模
  - 动态建模--可以一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象
- **继承**（inheritance）：
  - 通过继承联系在一起的类构成一种层次关系。
  - 通常在层次关系的根部有一个**基类**（base class）。
  - 其他类直接或者简介从基类继承而来，这些继承得到的类成为**派生类**（derived class）。
  - 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。
  - 对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成**虚函数**（virtual function）。
  - 派生类必须通过使用**类派生列表**（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。`class Bulk_quote : public Quote{};`
    - public关键词，表示我们完全可以把Bulk_quote的对象当成Quote的对象使用
  - 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上`virtual`关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个`override`关键字。
```c++
class Quote {
  public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
}

class Bulk_quote : public Quote {
  public :
    double net_price(std::size_t) const override;
}
```
- **动态绑定**（dynamic binding，又称运行时绑定）：
  - 使用同一段代码可以分别处理基类和派生类的对象。
  - 函数的运行版本由实参决定，即在运行时选择函数的版本。
  - 在c++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定
```c++
double print_total(ostream &os,const Quote &item, size_t n) {
  //根据传入对象类型调用Quote：：net_price或 Bulk_quote ::net_price
  double ret =item.net_price(n);
  os <<"ISBN: " << item.isbn() 
    << "# sold: " << n << "total due:" << ret << endl;
  return ret;
}

print_total(cout, basic,20)
print_total(cout, bulk,20)
```

## 定义基类和派生类

### 定义基类

- 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
  - `virtual ~Quote() =default;//对析构进行动态绑定`
- 基类通过在其成员函数的声明语句前加上关键字`virtual`使得该函数执行**动态绑定**。
- 如果成员函数没有被声明为虚函数，则解析过程发生在编译时而非运行时。
- 除构造函数外的非静态函数都可以是虚函数。
- virtual只能出现在类内部的声明语句之前，不能用于类外部的函数定义
- 若一个函数在基类中时虚函数，在派生类中隐式地也是虚函数
- 访问控制：
  - `protected` ： 基类和和其派生类还有友元可以访问。
  - `private` ： 只有基类本身和友元可以访问，派生类也不能访问。

### 定义派生类

- 派生类必须通过类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有一下三种访问说明符的一个：`public`、`protected`、`private`。
  - 访问说明符的作用：控制派生类从基类继承而来的成员是否对派生类的用户可见
  - 若一个派生类时公有的则基类的公有成员也是派生类接口的组成部分。
  - 也能将公有派生类型的对象绑定到基类的引用或指针上
- C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个`override`关键字。
  - 或是const成员函数的const关键词后
  - 在引用成员函数的引用限定符后
#### 派生类对象及派生类向基类的类型转换 
- 派生类组成部分
  - 派生类自己定义的（非静态）成员的子对象
  - 一个与该派生类继承的基类对应的子对象
  - 多个基类，多个2的子对象
- 继承自基类的部分和派生类自定义的部分不一定是连续存储的
- 可以把派生类对象（引用/指针）用在基类引用/指针的地方
  - 派生类到基类的类型转换，隐式执行
  - 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在
- 派生类构造函数：派生类必须使用基类的构造函数去初始化它的基类部分。
  - 首先初始化基类部分，然后按照声明顺序依次初始化派生类的成员
#### 派生类使用基类成员 
- 派生类可以使用基类public和project成员
- 派生类的作用域嵌套在基类的作用域之内
#### 继承与静态成员 
- 静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。
  - 遵循访问控制规则
#### 派生类的声明 
  - 声明中不包含它的派生列表。
  - `class Bulk_quote;`
#### 被用作基类的类
- 若想用某个类用作基类，则该类必须已经定义而非仅仅声明
- 直接基类，间接基类

#### 防止继承的发生
- C++11新标准提供了一种防止继承的方法，在类名后面跟一个关键字`final`。
  - `class NoDerived final{};`
  - `class Last final : Base {};`

### 类型转换与继承

- 理解基类和派生类之间的类型抓换是理解C++语言面向对象编程的关键所在。
- 可以将基类的指针或引用绑定到派生类对象上。
  - 引用或指针绑定规则：引用或指针的类型应该与对象类型一致，或者对象的类型含有一个可接受的const类型转换规则
#### 静态类型与动态类型 
- 基类的指针或引用的静态类型可能与其动态类型不一致
- 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致
#### 不存在从基类向派生类的隐式类型转换... 
- 编译器在编译时无法确定某个特定的转换在运行时是否安全，因为编译器只能通过检查指针或引用的静态类型来推断转换是否合法
- 如果一个基类含有一个或者多个虚函数，可用dynamic_cast请求一个类型转换，该转换的安全检测将在运行时执行
- 若我们已知摸个基类像派生类的转换时安全的，则可用statci_cast来强制覆盖掉编译器的检查工作

- 派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。

#### 类型转换，切掉（sliced down）
- 当执行初始化或赋值一个类类型的对象时，实际上调用参数（赋值构造/赋值运算符）这些函数通常包含的参数类型时类类型的const版本引用
- 当我们用一个派生类对象为一个基类对象赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略。实际执行的事基类的构造函数，赋值/移动操作函数

#### 关键概念： 存在继承关系的类型之间的转换规则 
- 要理解在具有继承关系的类之间发生的类型转换，三点很重要
  - 从派生类向基类的类型转换只对指针或引用类型有效
  - 基类向派生类不存在隐式类型转换
  - 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可型。
- 可以通过（显示或隐式）定义拷贝控制成员，将一个派生类对象拷贝移动赋值给一个基类对象。不过这种操作只处理派生类对象的基类部分453

## 虚函数

- 使用虚函数可以执行动态绑定。
- OOP的核心思想是多态性（polymorphism）。
  - 引用或指针的静态类型与动态类型不同正是C++语言支持多态性的根本
- 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。
  - 若通过普通类型（非引用非指针）的表达式调用虚函数，在编译时就会调用的版本确定。如base.net_price(20)
### 派生类中的虚函数 
- 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上`virtual`关键字，也可以不加。一旦被声明虚，在所有派生类中都是虚
- 派生类中的虚函数覆盖，它的形参类型必须与被他覆盖的基类函数完全一致
  - 返回类型也必须与基类函数匹配，除了虚函数返回类型时类本身的指针或引用时，但要求从派生类到基类的类型转换是可访问的
- C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函
  - 如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数，编译器会认为它们相互对立。加上`override`可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。
  - 加上final后派生再覆盖也会报错
### 虚函数与默认实参 
- 如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使运行时传入派生类中的函数版本
- 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。
### 回避虚函数的机制 
- 不希望虚函数动态绑定，而是执行某个特定版本
  - 何时使用：通常当一个派生类的虚函数调用覆盖的基类的虚函数版本时
    - 基类中的部分完成共同任务，派生类完成特有任务
    - 若没有使用：：则派生类中对基类的虚函数调用部分被认定为派生类自身版本调用而无限递归
  - `double undiscounted = baseP-> Quote::net_price(42);`在编译时完成解析
- 通常，只有成员函数（或友元）中的代码才需要使用**作用域运算符**（`::`）来回避虚函数的机制。

## 抽象基类

- **纯虚函数**（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。纯虚函数无需定义，只用在函数体的位置前书写`=0`就可以将一个虚函数说明为纯虚函数。
  - `double net_price(std::size_t) const = 0`
  - 要像对一个纯虚函数定义，必须在类的外部
### 含有纯虚函数的类是**抽象基类** （abstract base class）
 - 不能创建抽象基类的对象。
 - 定义抽象基类的派生，并覆盖纯虚
### 派生类构造函数只初始化它的直接基类 
- 从上往下初始化

### 重构 
- 将派生类定义为抽象基类，在Quote的体系中增加Disc_quote抽象基类时重构的一个典型实例。
- 重构负责重新设计类的体系以便将操作和/或数据从一个类移移动到另一个类
- 重构后必须重新编译相关类

## 访问控制与继承
- 每个类分别控制着其成员对于派生类来说是否可访问。

### 受保护的成员 
- `protected`说明符可以看做是`public`和`private`中的产物。
  - 类似于私有成员，受保护的成员对类的用户来说是不可访问的。
  - 类似于公有成员，受保护的成员对于派生类的成员和友元来说是可访问的。
  - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。
- 规定
  - 派生类的成员和友元只能访问派生类对象中的基类部分受保护成员
  - 普通的基类对象中的成员不具有特殊的访问权限
### 派生访问说明符：struct Priv_Derv:private Base{}; 
  - 对于派生类的成员（及友元）能否访问其直接积累的成员没什么影响。
  - 派生访问说明符的目的是：控制派生类用户（包括派生的派生）对于基类成员的访问权限。比如`struct Priv_Drev: private Base{}`意味着在派生类`Priv_Drev`中，从`Base`继承而来的部分都是`private`的。
    - 也可以控制继承自派生类的新类的用户访问权限
### 派生类向基类转换的可访问性 
- 受具体转换代码和派生类的派生访问说明符影响
  - 只有当D public 地继承B，用户才能使用派生类向基类的转换；若D private或projected地继承B，用户不能使用该转换
  - 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派神类向其直接基类的类型转换对于派生类的成员和友元永远是可访问的
  - 若D继承B的方式是public或projected的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，若D继承B的方式是私有的，则不能使用
  - 对于代码中某个节点，若基类的公有成员是可访问的，则派生类向基类的类型转换也是可以访问的；反之不行
- 类的成员和友元都可以访问，既能访问公有也能访问私有
- 基类接口成员声明成公有的类；将其实现部分分成两组：
  - 一组可供派生类访问projected，另一组只能由基类及基类的友元访问private
### 友元和继承 
- 每个类负责控制自己的成员的访问权限
- 当一个类将另一个类声明成友员时，这种友元关系只对做出声明的类有效。对于原来那个类，其友元的基类或者派生类不具有特殊访问能力
- 友元关系不能继承。
### 改变个别成员的可访问性 
- 使用`using`。
  - 可标明直接或间接基类的成员
- 默认情况下，使用`class`关键字定义的派生类是私有继承的；使用`struct`关键字定义的派生类是公有继承的。
```c++
class Derived : private Base {
  public :
      using Base ::size;
  project:
      using Base :: n;
}
```
### 默认的继承保护级别 
```c++
class Base {}; 
struct D1 : Base {} //默认public继承
class  D2 : Base {} //默认private继承
```
- struct 和 class 关键字声明类的不同，仅仅在于默认成员访问说明符和默认派生访问说明符

## 继承中的类作用域

- 每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。

### 在编译时进行名字的查找 
- 一个对象、引用或指针的静态类型决定该对象的哪些成员可见，即使动态类型和静态成员与动态成员不一致。
- 只能通过一个类及其派生类的对象、引用或指针使用其public成员
### 名字冲突和隐藏，通过作用域来使用隐藏的成员 
- 派生类的成员将隐藏同名的基类成员。
- `struct Derived : Base { int get_base_mem() {return Base::mem;}};`
  - 作用域运算符将覆盖原有的查找规则
- 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。

### 名字查找与继承 
- `p -> mem()`依次执行
  - 先确定p（或obj）的静态类型。因为调用的是一个成员，所以改类型必然时类类型
  - 在p（或obj）的静态类型对应的类中查找mem。若找不到，则依次在直接基类中不断查找到达继承链的顶端。若找遍了该类及其基类仍然找不到，则编译器报错
  - 一旦找到了mem，就进行常规的类型检查以确认对于当前找到的mem，本次调用是否合法
    - 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：
      - 若mem是虚函数且我们是通过引用或指针进行调用，则编译器产生的代码将在运行时确定倒是允许该虚函数的哪个版本，依据是对象的动态类型
      - 若mem不是虚函数或者我们通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用
### 名字查找先于类型检查 
- 内层作用域函数不会重载外层函数。而是隐藏，即使（形参列表不一样）
```c++
struct Base {
  int memfcn();
}
struct Derived : Base {
  int memfcn(int);  //隐藏基类的memfcn
}
Derived d; Base b;
b.memfcn() //调用Base::memfcn()
d.memfcn(10) //调用Derived::memfcn(int)
d.memfcn() // 错误：参数列表为空的memfcn被隐藏
d.Base::memfcn() //正确
```
- 第三个，d中，编译器首先在Derived中查找名字memfcn，因为Derived确实有定义一个名为memefcn的函数，所以查找终止。

### 虚函数与作用域 
### 通过基类调用隐藏的虚函数 
### 覆盖重载的函数 
- 无论成员函数是否是虚函数都能重载，派生类可以覆盖重载函数的0个或多个实例。但是派生类若希望所有重载版本都可见，那么全部一个个覆盖重载繁琐
- 可以使用using+函数名（不用加形参列表）就可把该函数所有重载实例添加到派生类作用域中。
  - 此时派生类只要定义其特有的函数就可以了
- 类内using声明的一般规则同样适用于重载函数的名字；基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问，实际上是对using声明点的访问


## 构造函数与拷贝控制

### 虚析构函数

- 基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。
  - 基类的虚拟析构函数不一定需要拷贝和赋值操作
- 如果基类的析构函数不是虚函数，则`delete`一个指向派生类对象的基类指针将产生未定义的行为。
- 虚拟析构函数将阻止合成移动操作
  - 如果一个类定义了析构函数，即使是=default的编译器也不会为这个类合成移动操作
  - 基类没有定义移动，派生类也不会合成
- `virtual ~Quote();`

### 合成拷贝控制与继承

- 基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。
  - 如构造函数由下往上调用，由上往下进行初始化运行
  - 基类定义虚拟析构函数显示使用，派生类合成析构函数，隐式地使用
    - 派生类销毁自己的和自己直接基类的成员，该直接基类友销毁自己直接基类，直到继承链顶端

#### 派生类中删除的拷贝控制与基类的关系 ####
- 基类或派生类也能将其合成的默认构造函数或任一拷贝控制成员定义成被删除的函数
- 以下定义基类的方式也可能导致有的派生类成员成为被删除函数：
  - 若基类中的默认构造、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，因为编译器不能使用基类成员来执行派生类对象基类部分的构造，赋值或销毁操作
  - 若基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分
  - 若基类中的移动操作是删除的或不可访问的，那么派生类中概函数将是被删除的吗因为派生类基类部分不可移动。若积累析构函数是删除或不可访问，则派生类的移动构造函数也将是删除的
- 若派生类想要移动或拷贝要定义自己的函数，其中要考虑如何拷贝移动基类部分成员。实际中，若基类无则派生类也不会定义

#### 移动操作与继承 ####
- 若因为定义虚析构函数后，派生类需要移动操作
  - 首先应该在基类中定义，显式定义（=default）,
  - 一旦定义了移动操作也需要显示定义拷贝操作
  - 除非派生类友排斥移动成员，否则派生类将自动获得合成的移动操作

### 派生类的拷贝控制成员

- 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。
- 派生类析构函数：派生类析构函数先执行，然后执行基类的析构函数。

#### 定义派生类的拷贝或移动构造函数
```c++
class Base {...};
class D: public Base {
  public :
      //默认情况下，基类的默认构造函数初始化对象的积基类部分
      //要想使用拷贝或移动构造函数，必须在构造函数初始值列表中
      //显式地调用该构造函数
      D(const D& d): Base(d) //拷贝基类成员
      /*D的成员的初始值*/{/*....*/}
      D(D&& d): Base(std::move(d))  //移动基类成员
      /*D的成员的初始值*/{/*.....*/}
};


D(const D& d) {}//成员初始值，但为提供基类初始值
//D的这个拷贝构造函数可能是不正确的定义
//基类被默认初始化，而非拷贝
```
- Base（d）匹配base的构造函数并把对象d绑定到该构造函数的Base&形参上，Base构造函数负责将d的基类部分拷贝给要创建的对象。
- 默认，基类默认构造函数初始化派生类对象基类部分。若想拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数

#### 派生类赋值运算符 ####
```c++
//Base::operator=(const Base&)不会被自动调用
D &D::operator=(const D &rhs) {
  Base::operator=(rhs);//为基类部分赋值
  //按照过去的方式为派生类的成员赋值
  //酌情处理自赋值及释放已有资源等情况
  return *this;
}
```
- 若基类部分赋值正确，基类运算符将释放掉其左侧运算对象的基类部分的旧值，利用rhs为其赋一个新值

#### 派生类析构函数 ####
- 对象成员被隐式销毁，对象的基类部分也是隐式销毁。与构造及赋值运算符不同，派生类的析构函数只负责销毁由派生类自己分配的资源

```c++
class D: public Base {
  public: 
      //Base::~Base自动调用执行
      ~D(){}
}
```
- 执行顺序与创建顺序相反：派生类析构函数首先执行，再基类析构函数

#### 在构造函数和析构函数中调用虚函数 ####
- 若构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本


### 继承的构造函数

- C++11新标准中，派生类可以重用其直接基类定义的构造函数。
- 如`using Disc_quote::Disc_quote;`，注明了要继承`Disc_quote`的构造函数。
- 一般using是将某个名字在当前作用域可见，这里是让编译器，对于基类的每个构造函数，让编译器生成一个与之对应的派生类构造函数。
```c++
derived(parms) :base(args) {}
Bulk_quote(const std::string& bool, double price,std::size_t qty,double disc) : Disc_quote(book,price,qty, disc) {}
```
#### 继承的构造函数的特点 ####
- using声明的构造函数不会改变该构造函数的访问级别。不管using声明在哪，基类的私有构造函数在派生类中还是一个私有构造函数
- using不能指定explicit或constexpr。若基类的构造函数是explicit或constexpr的，则继承的构造函数也拥有相同的属性。
- 但一个基类构造函数含有默认实参时，这些实参不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。
- 若基类有几个构造函数，除了两个特例，大多数时候派生类会继承所有这些构造函数。例外：
  - 派生类可以继承一部分构造函数，而为其他构造函数定义自己版本
    - 若派生类定义的构造函数与基类的构造函数具有相同的参数列表，则构造函数不会被继承。定义在派生类中的构造函数将替换继承来的构造函数
  - 默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被用作用户定义的构造函数来使用，因此，若一个类只含有继承的构造函数，则它也有一个合成的默认构造函数

## 容器与继承

- 当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。
- 派生类对象直接赋值给基类对象，其中的派生类部分会被切掉。
  - `vector<Base> bs；`不能存派生，会被切掉派生部分
- 在容器中放置基类（智能）指针而非对象。
  - 这样动态类型既可以是基类，也可以是派生类类型
  - `vector<shared_ptr<Quote>> basket;`
  - `basked.push_bask(make_shared<Bulk_quote<(...));`
    - 在push'back时把派生类智能指针，转化为基类智能指针
  - `cout<<basket.back()->net_price(15)<endl`
    - 调用钱必须解引用以获得对象，然后调用,->
- 对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以经常定义一些辅助的类来处理这些复杂的情况。


## 文本查询程序再探

- 使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。

### 面向对象的解决方案

- 将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：
  - `WordQuery`
  - `NotQuery`
  - `OrQuery`
  - `AndQuery`  
- 这些类包含两个操作：
  - `eval`：接受一个`TextQuery`对象并返回一个`QueryResult`。
  - `rep`：返回基础查询的`string`表示形式。
- 继承和组合：
  - 当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。
  - 类型之间另一种常见的关系是“有一个（Has A）”的关系。
- 对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。

**Query程序设计**:

| 操作 | 解释 |
|-----|-----|
| `Query`程序接口类和操作 |  |
| `TextQuery` | 该类读入给定的文件并构建一个查找图。包含一个`query`操作，它接受一个`string`实参，返回一个`QueryResult`对象；该`QueryResult`对象表示`string`出现的行。 |
| `QueryResult` | 该类保存一个`query`操作的结果。 |
| `Query` | 是一个接口类，指向`Query_base`派生类的对象。 |
| `Query q(s)` | 将`Query`对象`q`绑定到一个存放着`string s`的新`WordQuery`对象上。 |
| `q1 & q2` | 返回一个`Query`对象，该`Query`绑定到一个存放`q1`和`q2`的新`AndQuery`对象上。 |
| `q1 | q2` | 返回一个`Query`对象，该`Query`绑定到一个存放`q1`和`q2`的新`OrQuery`对象上。 |
| `~q` | 返回一个`Query`对象，该`Query`绑定到一个存放`q`的新`NotQuery`对象上。 |
| `Query`程序实现类 |  |
| `Query_base` | 查询类的抽象基类 |
| `WordQuery` | `Query_base`的派生类，用于查找一个给定的单词 |
| `NotQuery` | `Query_base`的派生类，用于查找一个给定的单词 |
| `BinaryQuery` | `Query_base`的派生类，查询结果是`Query`运算对象没有出现的行的集合 |
| `OrQuery` | `Query_base`的派生类，返回它的两个运算对象分别出现的行的并集 |
| `AndQuery` | `Query_base`的派生类，返回它的两个运算对象分别出现的行的交集 |
